-- @path OntoUML=/OntoUML2Alloy/OntoUML.ecore

module OntoUML2Alloy; -- Module Template
create OUT : OntoUML refining IN : OntoUML;

helper def: path : String = '/OntoUML2Alloy/specification.als';
helper def: signature_text : String = '';
helper def: relation_relations : String = '';
helper def: directedbinaryrelationship_generalization() : String = OntoUML!DirectedBinaryRelationship.allInstances()->select(x | not x.source->exists(y | if y.oclIsKindOf(OntoUML!Property) then (thisModule.derive_endType(y).oclIsKindOf(OntoUML!StructuralDatatype)) else false endif))->iterate(x; directedbinaryrelationship: String = '' | let gen : OrderedSet(OntoUML!Classifier) = thisModule.derive_generalization(x)->collect(y | thisModule.derive_general(y)) in (if (gen.size() > 0) then (directedbinaryrelationship + '	' + x.name + ' in ' + thisModule.names_disjunction_set2(gen) + '\n') else directedbinaryrelationship endif));
helper def: association_generalization() : String = OntoUML!Association.allInstances()->iterate(x; association: String = '' | let gen : OrderedSet(OntoUML!Classifier) = thisModule.derive_generalization(x)->collect(y | thisModule.derive_general(y)) in (if (gen.size() > 0) then (association + '	' + x.name + ' in ' + thisModule.names_disjunction_set2(gen) + '\n') else association endif));
helper def: relation_generalization() : String = thisModule.directedbinaryrelationship_generalization() + thisModule.association_generalization();
helper def: signature_names() : String = thisModule.names_union_set(OntoUML!SubstanceSortal.allInstances()->union(OntoUML!MomentClass.allInstances()));
helper def: relation_phases() : String = OntoUML!GeneralizationSet.allInstances()->select(x | if (x.generalization.size() > 0) then (if (x.generalization->forAll(y | thisModule.derive_specific(y).oclIsKindOf(OntoUML!Phase))) then true else false endif) else false endif)->iterate(x; phase_generalizationset: String = '' | phase_generalizationset + '	disj ' + thisModule.names_list(x.generalization->iterate(y; phases: OrderedSet(OntoUML!Phase) = OrderedSet{} | phases.including(thisModule.derive_specific(y)))) + ': set ' + thisModule.derive_general(x.generalization->any(y | true)).name + (if (thisModule.derive_general(x.generalization->any(y | true)).oclIsKindOf(OntoUML!SubstanceSortal)) then ' :> domain_of_quantification,\n' else ',\n' endif));
helper def: relation_roles() : String = OntoUML!Role.allInstances()->iterate(x; role: String = '' | let gen : OrderedSet(OntoUML!Generalization) = thisModule.derive_generalization(x)->collect(y | thisModule.derive_general(y)) in (role + '	' + x.name + ': set ' + thisModule.names_disjunction_set2(gen) + ',\n'));
helper def: relation_mixins() : String = OntoUML!Mixin.allInstances()->iterate(x; mixin: String = '' | mixin + '	' + x.name + ': set ' + thisModule.subTypes_name_union_set_special_rigid_sortal_subtypes(x) + ',\n');
helper def: relation_rolemixins() : String = OntoUML!RoleMixin.allInstances()->iterate(x; rolemixin: String = '' | rolemixin + '	' + x.name + ': set ' + thisModule.subTypes_name_union_set(x) + ',\n');
helper def: signature_declarations_world() : String = 'abstract sig World {\n	domain_of_quantification: some (' + thisModule.signature_names() + '),\n' + thisModule.relation_phases() + thisModule.relation_roles() + thisModule.relation_mixins() + thisModule.relation_rolemixins() + thisModule.relation_relations + '}';
helper def: signature_facts_world : String = '\n' + thisModule.relation_generalization();
helper def: signature_world() : String = thisModule.signature_declarations_world() + if (thisModule.signature_facts_world <> '') then ('{' + thisModule.signature_facts_world + '}') else '' endif;
helper def: function_text : String = '';
helper def: fact_text : String = '';
helper def: pairwise_disjoint_Classifiers : String = '';
helper def: command_text : String = '';
helper def: final_text() : String = thisModule.signature_text + '\n' + thisModule.function_text + '\n' + thisModule.signature_world() + '\n' + thisModule.pairwise_disjoint_Classifiers + '\n' + thisModule.fact_text + '\n' + thisModule.command_text;

helper def: derive_source(p: OntoUML!Property) : OntoUML!DirectedBinaryRelationship = OntoUML!DirectedBinaryRelationship.allInstances()->any(x | x.source->includes(p) or x.sourceAux2->includes(p));
helper def: derive_target(p: OntoUML!Property) : OntoUML!DirectedBinaryRelationship = OntoUML!DirectedBinaryRelationship.allInstances()->any(x | x.target->includes(p) or x.targetAux2->includes(p));
helper def: derive_endType(p: OntoUML!Property) : OntoUML!Type = if (not thisModule.derive_source(p)->oclIsUndefined()) then (if thisModule.derive_source(p).sourceAux1->forAll(x | x.oclIsKindOf(OntoUML!Type)) then thisModule.derive_source(p).sourceAux1->any(x | true) else OclUndefined endif) else if (not thisModule.derive_target(p)->oclIsUndefined()) then (if thisModule.derive_target(p).targetAux1->forAll(x | x.oclIsKindOf(OntoUML!Type)) then thisModule.derive_target(p).targetAux1->any(x | true) else OclUndefined endif) else if (p.associationEndPositionAux = 1) then p.associationEnd.associationEndAux1->any(x | true) else if (p.associationEndPositionAux = 2) then p.associationEnd.associationEndAux2->any(x | true) else OclUndefined endif endif endif endif;
helper def: derive_specific(g: OntoUML!Generalization) : OntoUML!Classifier = g.target->any(x | x.oclIsKindOf(OntoUML!Classifier));
helper def: derive_general(g: OntoUML!Generalization) : OntoUML!Classifier = g.source->any(x | x.oclIsKindOf(OntoUML!Classifier));
helper def: derive_generalization(c: OntoUML!Classifier) : OrderedSet(OntoUML!Generalization) = OntoUML!Generalization.allInstances()->select(x | thisModule.derive_specific(x) = c);
helper def: allSuperTypes(c: OntoUML!Classifier) : OrderedSet(OntoUML!Element) = if thisModule.derive_generalization(c)->forAll(x | x.oclIsUndefined()) then Set{} else Set{thisModule.derive_generalization(c)->collect(x | thisModule.derive_general(x)), thisModule.derive_generalization(c)->collect(x | if thisModule.derive_general(x).oclIsKindOf(OntoUML!Classifier) then thisModule.allSuperTypes(thisModule.derive_general(x)) else Set{} endif)}->flatten() endif;

helper def: names_list(os: OrderedSet(OntoUML!NamedElement)) : String = let names: String = os->iterate(x; names: String = '' | names + x.name + ', ') in (if (names.size() > 0) then names.substring(1,(names.size()-2)) else '' endif);
helper def: names_union_set(os: OrderedSet(OntoUML!NamedElement)) : String = let names: String = os->iterate(x; names: String = '' | names + x.name + ' + ') in (if (names.size() > 0) then names.substring(1,(names.size()-3)) else '' endif);
helper def: names_union_set_special_rigid_sortal_subtypes(os: OrderedSet(OntoUML!NamedElement)) : String = let names: String = os->iterate(x; names: String = '' | if (x.oclIsKindOf(OntoUML!RigidSortalClass)) then (names + x.name + ':>domain_of_quantification + ') else (names + x.name + ' + ') endif) in (if (names.size() > 0) then names.substring(1,(names.size()-3)) else '' endif);
helper def: names_disjunction_set(os: OrderedSet(OntoUML!NamedElement)) : String = let names: String = os->iterate(x; names: String = '' | names + x.name + ' & ') in (if (names.size() > 0) then names.substring(1,(names.size()-3)) else '' endif);
helper def: domain_function(e: OntoUML!Element): String = if (e.oclIsKindOf(OntoUML!SubstanceSortal) or e.oclIsKindOf(OntoUML!Relator) or e.oclIsKindOf(OntoUML!Mode)) then ':>domain_of_quantification' else '' endif;
helper def: names_disjunction_set2(os: OrderedSet(OntoUML!NamedElement)) : String = let names: String = os->iterate(x; names: String = '' | names + x.name + thisModule.domain_function(x) + ' & ') in (if (names.size() > 0) then names.substring(1,(names.size()-3)) else '' endif);

helper def: superTypes_set(e: OntoUML!Element) : OrderedSet(OntoUML!Element) = OntoUML!Generalization.allInstances()->select(x | x.target->any(y | true) = e)->collect(x | x.source)->flatten();
helper def: superTypes_name_list(e: OntoUML!Element) : String = thisModule.names_list(thisModule.superTypes_set(e));
helper def: superTypes_name_union_set(e: OntoUML!Element) : String = thisModule.names_union_set(thisModule.superTypes_set(e));
helper def: superTypes_name_disjunction_set(e: OntoUML!Element) : String = thisModule.names_disjunction_set(thisModule.superTypes_set(e));
helper def: superTypes_set_equality(e1: OntoUML!Element, e2: OntoUML!Element) : Boolean = thisModule.superTypes_set(e1).asSet() = thisModule.superTypes_set(e2).asSet();
helper def: classifiers_with_same_supertypes : Set(Set(OntoUML!Element)) = let c: Set(OntoUML!Classifier) = OntoUML!Classifier.allInstances() in (c->iterate(x; acc: Set(Set(OntoUML!Element)) = Set{} | acc->including(c->select(y | thisModule.superTypes_set_equality(x,y))->asSet())));
helper def: subTypes_set(e: OntoUML!Element) : OrderedSet(OntoUML!Element) = OntoUML!Generalization.allInstances()->select(x | x.source->any(y | true) = e)->collect(x | x.target)->flatten();
helper def: subTypes_name_union_set(e: OntoUML!Element) : String = thisModule.names_union_set(thisModule.subTypes_set(e));
helper def: subTypes_name_union_set_special_rigid_sortal_subtypes(e: OntoUML!Element) : String = thisModule.names_union_set_special_rigid_sortal_subtypes(thisModule.subTypes_set(e));
helper def: generalization_Sets_of_superTypes_of(c: OntoUML!Classifier) : OrderedSet(OntoUML!GeneralizationSet) = OntoUML!Generalization.allInstances()->select(x | x.target->any(y | true) = c)->collect(x | x.generalizationSet)->flatten();
helper def: generalization_Sets_of_subKinds_subTypes_of(c: OntoUML!Classifier) : OrderedSet(OntoUML!GeneralizationSet) = OntoUML!Generalization.allInstances()->select(x | (x.source->any(y | true) = c) and (x.target->forAll(y | y.oclIsKindOf(OntoUML!SubKind))))->collect(x | x.generalizationSet)->flatten();
helper def: generalization_relational_constraint(set: OrderedSet(OntoUML!Classifier)) : String = set->iterate(x; str: String = '' | let gen : OrderedSet(OntoUML!Generalization) = thisModule.derive_generalization(x)->collect(y | thisModule.derive_general(y)) in (if (gen.size() > 0) then (str + '	' + x.name + ' in ' + thisModule.names_disjunction_set2(gen) + '\n') else str endif)); -- For a set of relations.
helper def: top_level_rigid_sortals_connected_on_source(d: OntoUML!DirectedRelationship) : OrderedSet(OntoUML!Classifier) = thisModule.allSuperTypes(thisModule.derive_endType(d.source->any(x | true)))->including(thisModule.derive_endType(d.source->any(x | true)))->select(x | x.oclIsKindOf(OntoUML!SubstanceSortal) or x.oclIsKindOf(OntoUML!MomentClass) or x.oclIsKindOf(OntoUML!Datatype));
helper def: top_level_rigid_sortals_connected_on_target(d: OntoUML!DirectedRelationship) : OrderedSet(OntoUML!Classifier) = thisModule.allSuperTypes(thisModule.derive_endType(d.target->any(x | true)))->including(thisModule.derive_endType(d.target->any(x | true)))->select(x | x.oclIsKindOf(OntoUML!SubstanceSortal) or x.oclIsKindOf(OntoUML!MomentClass) or x.oclIsKindOf(OntoUML!Datatype));
helper def: top_level_rigid_sortals_connected_on_associationEnd(d: OntoUML!DirectedRelationship, i : Integer) : OrderedSet(OntoUML!Classifier) = thisModule.allSuperTypes(thisModule.derive_endType(d.associationEnd->at(i)))->including(thisModule.derive_endType(d.associationEnd->at(i)))->select(x | x.oclIsKindOf(OntoUML!SubstanceSortal) or x.oclIsKindOf(OntoUML!MomentClass) or x.oclIsKindOf(OntoUML!Datatype));

helper def: is_top_level(e: OntoUML!Element) : Boolean = if (e.oclIsKindOf(OntoUML!SubstanceSortal) or e.oclIsKindOf(OntoUML!MomentClass)) then true else false endif;
helper def: name_side_source(e: OntoUML!Element) : String = let side: OntoUML!Element = thisModule.derive_endType(e.source->any(x | true)) in (if (thisModule.is_top_level(side)) then (side.name + ':>domain_of_quantification') else (side.name) endif);
helper def: name_side_target(e: OntoUML!Element) : String = let side: OntoUML!Element = thisModule.derive_endType(e.target->any(x | true)) in (if (thisModule.is_top_level(side)) then (side.name + ':>domain_of_quantification') else (side.name) endif);
helper def: name_side_associationEnd(e: OntoUML!Element, i: Integer) : String = let side: OntoUML!Element = thisModule.derive_endType(e.associationEnd->at(i)) in (if (thisModule.is_top_level(side)) then (side.name + ':>domain_of_quantification') else (side.name) endif);

helper def: cardinality(p: OntoUML!Property) : String = if ((p.lower = 0) and (p.upper = 1)) then 'lone' else (if ((p.lower = 1) and (p.upper = 1)) then 'one' else (if ((p.lower = 1) and (p.upper = 0-1)) then 'some' else 'set' endif) endif) endif;
helper def: cardinality_fact1(name_relation: String, name_side: String, p: OntoUML!Property) : String = if (p.lower = 0) then (if (p.upper = 0-1) then '' else ('	all x: ' + name_side + ' | #' + name_relation + '.x <= ' + p.upper.toString()) endif) else (if (p.upper = 0-1) then ('	all x: ' + name_side + ' | #' + name_relation + '.x >= ' + p.lower.toString()) else (if (p.lower <> p.upper) then ('	all x: ' + name_side + ' | (#' + name_relation + '.x >= ' + p.lower.toString() + ') and (#' + name_relation + '.x <= ' + p.upper.toString() + ')') else ('	all x: ' + name_side + ' | #' + name_relation + '.x = ' + p.lower.toString()) endif) endif) endif;
helper def: cardinality_fact2(name_relation: String, name_side: String, p: OntoUML!Property) : String = if (p.lower = 0) then (if (p.upper = 0-1) then '' else ('	all x: ' + name_side + ' | #x.' + name_relation + ' <= ' + p.upper.toString()) endif) else (if (p.upper = 0-1) then ('	all x: ' + name_side + ' | #x.' + name_relation + ' >= ' + p.lower.toString()) else (if (p.lower <> p.upper) then ('	all x: ' + name_side + ' | (#x.' + name_relation + ' >= ' + p.lower.toString() + ') and (#x.' + name_relation + ' <= ' + p.upper.toString() + ')') else ('	all x: ' + name_side + ' | #x.' + name_relation + ' = ' + p.lower.toString()) endif) endif) endif;
helper def: cardinality_mediation1(name_relation: String, p: OntoUML!Property) : String = if (p.lower = 0) then (if (p.upper = 0-1) then '' else ('	#' + name_relation + ' <= ' + p.upper.toString()) endif) else (if (p.upper = 0-1) then ('	#' + name_relation + ' >= ' + p.lower.toString()) else (if (p.lower <> p.upper) then ('	(#' + name_relation + ' >= ' + p.lower.toString() + ') and (#' + name_relation + ' <= ' + p.upper.toString() + ')') else ('	#' + name_relation + ' = ' + p.lower.toString()) endif) endif) endif;
helper def: cardinality_mediation2(name_relation: String, name_side: String, p: OntoUML!Property) : String = if (p.lower = 0) then (if (p.upper = 0-1) then '' else ('	all x: ' + name_side + ' | #((' + name_relation + '.x):>domain_of_quantification) <= ' + p.upper.toString()) endif) else (if (p.upper = 0-1) then ('	all x: ' + name_side + ' | #((' + name_relation + '.x):>domain_of_quantification) >= ' + p.lower.toString()) else (if (p.lower <> p.upper) then ('	all x: ' + name_side + ' | (#((' + name_relation + '.x):>domain_of_quantification) >= ' + p.lower.toString() + ') and (#((' + name_relation + '.x):>domain_of_quantification) <= ' + p.upper.toString() + ')') else ('	all x: ' + name_side + ' | #((' + name_relation + '.x):>domain_of_quantification) = ' + p.lower.toString()) endif) endif) endif;
helper def: cardinality_derivation1(name_relation: String, name_side: String, p: OntoUML!Property) : String = if (p.lower = 0) then (if (p.upper = 0-1) then '' else ('	all x: ' + name_side + ' | #x.' + name_relation + ' <= ' + p.upper.toString()) endif) else (if (p.upper = 0-1) then ('	all x: ' + name_side + ' | #x.' + name_relation + ' >= ' + p.lower.toString()) else (if (p.lower <> p.upper) then ('	all x: ' + name_side + ' | (#x.' + name_relation + ' >= ' + p.lower.toString() + ') and (#x.' + name_relation + ' <= ' + p.upper.toString() + ')') else ('	all x: ' + name_side + ' | #x.' + name_relation + ' = ' + p.lower.toString()) endif) endif) endif;
helper def: cardinality_derivation2(name_relation: String, name_side: String, p: OntoUML!Property) : String = if (p.lower = 0) then (if (p.upper = 0-1) then '' else ('	all x: ' + name_side + ' | #' + name_relation + '.x <= ' + p.upper.toString()) endif) else (if (p.upper = 0-1) then ('	all x: ' + name_side + ' | #' + name_relation + '.x >= ' + p.lower.toString()) else (if (p.lower <> p.upper) then ('	all x: ' + name_side + ' | (#' + name_relation + '.x >= ' + p.lower.toString() + ') and (#' + name_relation + '.x <= ' + p.upper.toString() + ')') else ('	all x: ' + name_side + ' | #' + name_relation + '.x = ' + p.lower.toString()) endif) endif) endif;
helper def: cardinality_characterization1(name_relation: String, p: OntoUML!Property) : String = if (p.lower = 0) then (if (p.upper = 0-1) then '' else ('	#' + name_relation + ' <= ' + p.upper.toString()) endif) else (if (p.upper = 0-1) then ('	#' + name_relation + ' >= ' + p.lower.toString()) else (if (p.lower <> p.upper) then ('	(#' + name_relation + ' >= ' + p.lower.toString() + ') and (#' + name_relation + ' <= ' + p.upper.toString() + ')') else ('	#' + name_relation + ' = ' + p.lower.toString()) endif) endif) endif;
helper def: cardinality_characterization2(name_relation: String, name_side: String, p: OntoUML!Property) : String = if (p.lower = 0) then (if (p.upper = 0-1) then '' else ('	all x: ' + name_side + ' | #((' + name_relation + '.x):>domain_of_quantification) <= ' + p.upper.toString()) endif) else (if (p.upper = 0-1) then ('	all x: ' + name_side + ' | #((' + name_relation + '.x):>domain_of_quantification) >= ' + p.lower.toString()) else (if (p.lower <> p.upper) then ('	all x: ' + name_side + ' | (#((' + name_relation + '.x):>domain_of_quantification) >= ' + p.lower.toString() + ') and (#((' + name_relation + '.x):>domain_of_quantification) <= ' + p.upper.toString() + ')') else ('	all x: ' + name_side + ' | #((' + name_relation + '.x):>domain_of_quantification) = ' + p.lower.toString()) endif) endif) endif;

entrypoint rule World() {
	do {
		thisModule.signature_text <- thisModule.signature_text + 'module model\n\n';
		thisModule.signature_text <- thisModule.signature_text + 'open world_structure[World]\n\n';
		thisModule.command_text <- 'run {}';
		thisModule.fact_text <- 'fact additional_facts {\n';
		thisModule.fact_text <- thisModule.fact_text + '	all w : World, x: (@next.w).domain_of_quantification | (x not in w.domain_of_quantification) => (x not in (( w. ^next).domain_of_quantification))\n';
		thisModule.fact_text <- thisModule.fact_text + '	all x: (' + thisModule.signature_names() + ') | some w: World | x in w.domain_of_quantification\n}\n';
		thisModule.text <- thisModule.final_text();
		thisModule.text.writeTo(thisModule.path);
		thisModule.debug('Module');
	}
}

rule SubstanceSortal2Signature {
    from
    	s: OntoUML!SubstanceSortal
	using {
		abstract_keyword : String = if ((s.isAbstract = true) or thisModule.generalization_Sets_of_subKinds_subTypes_of(s)->exists(x | x.isCovering = true)) then 'abstract ' else '' endif;
	}
	do {  
	    thisModule.signature_text <- thisModule.signature_text + abstract_keyword + 'sig ' + s.name + ' {}\n';
		thisModule.text <- thisModule.final_text();
		thisModule.text.writeTo(thisModule.path);
		thisModule.debug('SubstanceSortal ' + s.name);	
	}
}

rule SubKind2Subsignature {
    from
    	s: OntoUML!SubKind
	using {
		abstract_keyword : String = if ((s.isAbstract = true) or thisModule.generalization_Sets_of_subKinds_subTypes_of(s)->exists(x | x.isCovering = true)) then 'abstract ' else '' endif;
		supertype_keyword : String = if (thisModule.generalization_Sets_of_superTypes_of(s)->exists(x | x.isDisjoint = true)) then ' extends ' else (if (thisModule.superTypes_set(s).size() > 0) then ' in ' else '' endif) endif;
	}
	do {
	    thisModule.signature_text <- thisModule.signature_text + abstract_keyword + 'sig ' + s.name + supertype_keyword + thisModule.superTypes_name_list(s) + ' {}\n';
		thisModule.text <- thisModule.final_text();
		thisModule.text.writeTo(thisModule.path);
		thisModule.debug('SubKind ' + s.name);	
	}
}

rule Mode2Signature {
    from
    	m: OntoUML!Mode
	using {
		abstract_keyword : String = if ((m.isAbstract = true) or thisModule.generalization_Sets_of_subKinds_subTypes_of(m)->exists(x | x.isCovering = true)) then 'abstract ' else '' endif;
		supertype_keyword : String = if (thisModule.generalization_Sets_of_superTypes_of(m)->exists(x | x.isDisjoint = true)) then ' extends ' else (if (thisModule.superTypes_set(m).size() > 0) then ' in ' else '' endif) endif;
		characterizations : OrderedSet(OntoUML!Characterization) = OntoUML!Characterization.allInstances()->select(x | x.source->exists(y | if y.oclIsKindOf(OntoUML!Property) then (thisModule.derive_endType(y) = m) else false endif));
		characterizations_str : String = characterizations->iterate(x; str : String = '' | str + '	' + x.name + ': '+ thisModule.cardinality(x.target->any(y | true)) + ' ' + thisModule.allSuperTypes(thisModule.derive_endType(x.target->any(y | true)))->including(thisModule.derive_endType(x.target->any(y | true)))->select(x | x.oclIsKindOf(OntoUML!SubstanceSortal))->any(x | true).name + ',\n');
		characterizations_cardinalities : String = characterizations->iterate(x; str : String = '' | str + thisModule.cardinality_characterization1(x.name,x.target->any(y | true)) + '\n');
		signature_constraints : String = let str: String = characterizations_cardinalities in (if (str <> '') then ('{\n' + str + '}') else '' endif);
    	world_facts : String = let world_fact_str: String = '	all x: ' + m.name + ':>domain_of_quantification | ' + characterizations->iterate(x; str : String = '' | str + '(x.' + x.name + ' in ' + thisModule.derive_endType(x.target->any(y | true)).name + ') and ') in (if (world_fact_str.size() > 0) then world_fact_str.substring(1,(world_fact_str.size()-5)) + '\n' else '' endif);
	}
	do {
		world_facts <- world_facts + characterizations->iterate(x; str : String = '' | str + thisModule.cardinality_characterization2(x.name,thisModule.name_side_target(x),x.source->any(y | true)) + '\n');
	    thisModule.signature_text <- thisModule.signature_text + abstract_keyword + 'sig ' + m.name + supertype_keyword + thisModule.superTypes_name_list(m) + ' {\n' + characterizations_str + '}' + signature_constraints + '\n';
		thisModule.signature_facts_world <- thisModule.signature_facts_world + world_facts;
		thisModule.text <- thisModule.final_text();
		thisModule.text.writeTo(thisModule.path);
		thisModule.debug('Mode ' + m.name);	
	}
}

rule Relator2Signature {
    from
    	r: OntoUML!Relator
	using {
		abstract_keyword : String = if ((r.isAbstract = true) or thisModule.generalization_Sets_of_subKinds_subTypes_of(r)->exists(x | x.isCovering = true)) then 'abstract ' else '' endif;
		supertype_keyword : String = if (thisModule.generalization_Sets_of_superTypes_of(r)->exists(x | x.isDisjoint = true)) then ' extends ' else (if (thisModule.superTypes_set(r).size() > 0) then ' in ' else '' endif) endif;
		mediations : OrderedSet(OntoUML!Mediation) = OntoUML!Mediation.allInstances()->select(x | x.source->exists(y | if y.oclIsKindOf(OntoUML!Property) then (thisModule.derive_endType(y) = r) else false endif));
		derivations : OrderedSet(OntoUML!Derivation) = OntoUML!Derivation.allInstances()->select(x | x.target->exists(y | if y.oclIsKindOf(OntoUML!Property) then (thisModule.derive_endType(y) = r) else false endif));
		mediations_str : String = mediations->iterate(x; str : String = '' | str + '	' + x.name + ': '+ thisModule.cardinality(x.target->any(y | true)) + ' ' + thisModule.allSuperTypes(thisModule.derive_endType(x.target->any(y | true)))->including(thisModule.derive_endType(x.target->any(y | true)))->select(x | x.oclIsKindOf(OntoUML!SubstanceSortal))->any(x | true).name + ',\n');
		derivations_str : String = derivations->iterate(x; str : String = '' | let mediated_class1: OntoUML!ObjectClass = thisModule.derive_endType(thisModule.derive_endType(x.source->any(y | true)).associationEnd->at(1)) in let mediated_class2: OntoUML!ObjectClass = thisModule.derive_endType(thisModule.derive_endType(x.source->any(y | true)).associationEnd->at(2)) in let mediation1: OntoUML!Mediation = mediations->select(y | y.target->exists(z | if z.oclIsKindOf(OntoUML!Property) then (thisModule.derive_endType(z) = mediated_class1) else false endif))->at(1) in let mediation2: OntoUML!Mediation = mediations->select(y | y.target->exists(z | if z.oclIsKindOf(OntoUML!Property) then (thisModule.derive_endType(z) = mediated_class2) else false endif))->at(1) in (str + '	' + x.name + ': '+ mediation1.name + ' ' + thisModule.cardinality(mediation1.target->any(y | true)) + ' -> ' + thisModule.cardinality(mediation2.target->any(y | true)) + ' ' + mediation2.name + ',\n'));
    	mediations_generalization : String = thisModule.generalization_relational_constraint(mediations);
		derivations_generalization : String = thisModule.generalization_relational_constraint(derivations);
		mediations_cardinalities : String = mediations->iterate(x; str : String = '' | str + thisModule.cardinality_mediation1(x.name,x.target->any(y | true)) + '\n');
		derivations_cardinalities : String = derivations->iterate(x; str : String = '' | let mediated_class1: OntoUML!ObjectClass = thisModule.derive_endType(thisModule.derive_endType(x.source->any(y | true)).associationEnd->at(1)) in let mediated_class2: OntoUML!ObjectClass = thisModule.derive_endType(thisModule.derive_endType(x.source->any(y | true)).associationEnd->at(2)) in let mediation1: OntoUML!Mediation = mediations->select(y | y.target->exists(z | if z.oclIsKindOf(OntoUML!Property) then (thisModule.derive_endType(z) = mediated_class1) else false endif))->at(1) in let mediation2: OntoUML!Mediation = mediations->select(y | y.target->exists(z | if z.oclIsKindOf(OntoUML!Property) then (thisModule.derive_endType(z) = mediated_class2) else false endif))->at(1) in (str + thisModule.cardinality_derivation1(x.name,mediation1.name,mediation2.target->any(y | true)) + '\n' + thisModule.cardinality_derivation2(x.name,mediation2.name,mediation1.target->any(y | true)) + '\n'));
		signature_constraints : String = let str: String = mediations_generalization + derivations_generalization + mediations_cardinalities + derivations_cardinalities in (if (str <> '') then ('{\n' + str + '}') else '' endif);
		world_facts : String = let world_fact_str: String = '	all x: ' + r.name + ':>domain_of_quantification | ' + mediations->iterate(x; str : String = '' | str + '(x.' + x.name + ' in ' + thisModule.derive_endType(x.target->any(y | true)).name + ') and ') in (if (world_fact_str.size() > 0) then world_fact_str.substring(1,(world_fact_str.size()-5)) + '\n' else '' endif);
	}
	do {
		world_facts <- world_facts + mediations->iterate(x; str : String = '' | str + thisModule.cardinality_mediation2(x.name,thisModule.name_side_target(x),x.source->any(y | true)) + '\n');
		world_facts <- world_facts + derivations->iterate(x; str : String = '' | str + '	' + thisModule.derive_endType(x.source->any(y | true)).name + ' = (' + r.name + ':>domain_of_quantification).' + x.name + '\n');
	    thisModule.signature_text <- thisModule.signature_text + abstract_keyword + 'sig ' + r.name + supertype_keyword + thisModule.superTypes_name_list(r) + ' {\n' + mediations_str + derivations_str + '}' + signature_constraints + '\n';
		thisModule.signature_facts_world <- thisModule.signature_facts_world + world_facts;
		thisModule.text <- thisModule.final_text();
		thisModule.text.writeTo(thisModule.path);
		thisModule.debug('Relator ' + r.name);
	}
}

rule SimpleDatatype2Signature {
    from
    	s: OntoUML!SimpleDatatype
	using {
		abstract_keyword : String = if ((s.isAbstract = true) or thisModule.generalization_Sets_of_subKinds_subTypes_of(s)->exists(x | x.isCovering = true)) then 'abstract ' else '' endif;
		supertype_keyword : String = if (thisModule.generalization_Sets_of_superTypes_of(s)->exists(x | x.isDisjoint = true)) then ' extends ' else (if (thisModule.superTypes_set(s).size() > 0) then ' in ' else '' endif) endif;
	}
	do {
	    thisModule.signature_text <- thisModule.signature_text + abstract_keyword + 'sig ' + s.name + supertype_keyword + thisModule.superTypes_name_list(s) + ' {}\n';
		thisModule.text <- thisModule.final_text();
		thisModule.text.writeTo(thisModule.path);
		thisModule.debug('SimpleDatatype ' + s.name);
	}
}

rule StructuralDatatype2Signature {
    from
    	s: OntoUML!StructuralDatatype
	using {
		abstract_keyword : String = if ((s.isAbstract = true) or thisModule.generalization_Sets_of_subKinds_subTypes_of(s)->exists(x | x.isCovering = true)) then 'abstract ' else '' endif;
		supertype_keyword : String = if (thisModule.generalization_Sets_of_superTypes_of(s)->exists(x | x.isDisjoint = true)) then ' extends ' else (if (thisModule.superTypes_set(s).size() > 0) then ' in ' else '' endif) endif;
		datatype_relationships : OrderedSet(OntoUML!DatatypeRelationship) = OntoUML!DatatypeRelationship.allInstances()->select(x | x.source->exists(y | if y.oclIsKindOf(OntoUML!Property) then (thisModule.derive_endType(y) = s) else false endif));
		datatype_relationships_str : String = datatype_relationships->iterate(x; str : String = '' | str + '	' + x.name + ': '+ thisModule.cardinality(x.target->any(y | true)) + ' ' + thisModule.derive_endType(x.target->any(y | true)).name + ',\n');
		datatype_relationships_cardinalities : String = datatype_relationships->iterate(x; str : String = '' | str + thisModule.cardinality_mediation1(x.name,x.target->any(y | true)) + '\n');
		datatype_relationships_generalization : String = thisModule.generalization_relational_constraint(datatype_relationships);
		canonicity_fact : String = '	all x,y: ' + s.name + ' | ' + (let canonicity_fact_str : String = datatype_relationships->iterate(x; str : String = '(' | str + '(x.@' + x.name + ' = ' + 'y.@' + x.name + ') and ') in canonicity_fact_str.substring(1,(canonicity_fact_str.size()-5))) + ') implies (x = y)\n';
		signature_constraints : String = let str: String = datatype_relationships_generalization + datatype_relationships_cardinalities + canonicity_fact in (if (str <> '') then ('{\n' + str + '}') else '' endif);
	}
	do {
	    thisModule.signature_text <- thisModule.signature_text + abstract_keyword + 'sig ' + s.name + supertype_keyword + thisModule.superTypes_name_list(s) + ' {\n' + datatype_relationships_str + '}' + signature_constraints + '\n';
		thisModule.text <- thisModule.final_text();
		thisModule.text.writeTo(thisModule.path);
		thisModule.debug('StructuredDatatype ' + s.name);
	}
}

rule Category2Function {
    from
    	s: OntoUML!Category
	do {
	    if(thisModule.subTypes_set(s)->forAll(x | x.oclIsKindOf(OntoUML!Category)))
	    	thisModule.function_text <- thisModule.function_text + 'fun ' + s.name + ': univ {' + thisModule.subTypes_name_union_set(s) + '}\n';
	    else
	        thisModule.function_text <- thisModule.function_text + 'fun ' + s.name + ': (' + thisModule.subTypes_name_union_set(s) + ')' + ' {\n	' + thisModule.subTypes_name_union_set(s) + '\n}\n';
		thisModule.text <- thisModule.final_text();
		thisModule.text.writeTo(thisModule.path);
		thisModule.debug('Category ' + s.name);	
	}
}

rule Phase2Relation {
    from
    	p: OntoUML!Phase
	do {
		if (OntoUML!GeneralizationSet.allInstances()->select(x | if (x.generalization.size() > 0) then (if (x.generalization->exists(y | thisModule.derive_specific(y) = p)) then true else false endif) else false endif)->isEmpty()) {
	    	thisModule.relation_phases <- thisModule.relation_phases + '	' + p.name + ': set ' + thisModule.superTypes_name_union_set(p) + ':>domain_of_quantification,\n';
		}
		thisModule.signature_facts_world <- thisModule.signature_facts_world + '	all x: ' + thisModule.allSuperTypes(p)->select(x | x.oclIsKindOf(OntoUML!SubstanceSortal))->any(x | true).name + ' | some w: World | x in w.@' + p.name + '\n';
		thisModule.text <- thisModule.final_text();
		thisModule.text.writeTo(thisModule.path);
		thisModule.debug('Phase ' + p.name);
	}
}

rule Role2Relation {
    from
    	p: OntoUML!Role
	do {
		if (thisModule.superTypes_set(p)->forAll(x | not x.oclIsKindOf(OntoUML!AntiRigidSortalClass))) {
			thisModule.signature_facts_world <- thisModule.signature_facts_world + '	all x: ' + p.name + ' | some w: World | (x in w.@domain_of_quantification) and (x not in w.@' + p.name + ')\n';
		}
		else {
		    thisModule.signature_facts_world <- thisModule.signature_facts_world + '--	all x: ' + p.name + ' | some w: World | (x in w.@domain_of_quantification) and (x not in w.@' + p.name + ')\n';
		}
		thisModule.text <- thisModule.final_text();
		thisModule.text.writeTo(thisModule.path);
		thisModule.debug('Role ' + p.name);
	}
}

rule Mixin2Relation {
    from
    	m: OntoUML!Mixin
	do {
		thisModule.signature_facts_world <- thisModule.signature_facts_world + '	all x: (' + thisModule.subTypes_name_union_set_special_rigid_sortal_subtypes(m) + ') | x in ' + m.name + '\n';
	    thisModule.text <- thisModule.final_text();
		thisModule.text.writeTo(thisModule.path);
		thisModule.debug('Mixin ' + m.name);
	}
}

rule RoleMixin2Relation {
    from
    	r: OntoUML!RoleMixin
	do {
		thisModule.signature_facts_world <- thisModule.signature_facts_world + '	all x: (' + thisModule.subTypes_name_union_set(r) + ') | x in ' + r.name + '\n';
	    thisModule.text <- thisModule.final_text();
		thisModule.text.writeTo(thisModule.path);
		thisModule.debug('RoleMixin ' + r.name);
	}
}

rule Meronymic2Relation {
    from
    	m: OntoUML!Meronymic
    using {
    	    source_min_cardinality : Integer = m.source->any(x | true).lower;
    	    source_max_cardinality : Integer = m.source->any(x | true).upper;
    	    target_min_cardinality : Integer = m.target->any(x | true).lower;
    	    target_max_cardinality : Integer = m.target->any(x | true).upper;
    	    cardinality_source : String = '';
    	    cardinality_target : String = '';
			cardinality_fact_source : String = thisModule.cardinality_fact1(m.name,thisModule.name_side_source(m),m.target->any(x | true));
			cardinality_fact_target : String = thisModule.cardinality_fact2(m.name,thisModule.name_side_target(m),m.source->any(x | true));
			tlrss : OrderedSet (OntoUML!Classifier) = thisModule.top_level_rigid_sortals_connected_on_source(m);
			tlrst : OrderedSet (OntoUML!Classifier) = thisModule.top_level_rigid_sortals_connected_on_target(m);
			world_facts : String = '';
    	}
	do {
		if ((source_min_cardinality = 0) and (source_max_cardinality = 1)) {
		    cardinality_source <- 'lone';
		}
		else {
		    if ((source_min_cardinality = 1) and (source_max_cardinality = 1)) {
		        cardinality_source <- 'one';
		    }
		    else {
		        if ((source_min_cardinality = 1) and (source_max_cardinality = 0-1)) {
		            cardinality_source <- 'some';
		        }
		        else {
		            cardinality_source <- 'set';
		        }
		    }
		}
		if ((target_min_cardinality = 0) and (target_max_cardinality = 1)) {
		    cardinality_target <- 'lone';
		}
		else {
		    if ((target_min_cardinality = 1) and (target_max_cardinality = 1)) {
		        cardinality_target <- 'one';
		    }
		    else {
		        if ((target_min_cardinality = 1) and (target_max_cardinality = 0-1)) {
		            cardinality_target <- 'some';
		        }
		        else {
		            cardinality_target <- 'set';
		        }
		    }
		}
	    thisModule.relation_relations <- thisModule.relation_relations + '	' + m.name + ': set ' + thisModule.derive_endType(m.target->any(x | true)).name + (if (thisModule.derive_endType(m.target->any(x | true)).oclIsKindOf(OntoUML!SubstanceSortal)) then ':>domain_of_quantification' else '' endif) + ' ' + cardinality_target + ' -> ' + cardinality_source + ' ' + thisModule.derive_endType(m.source->any(x | true)).name + (if (thisModule.derive_endType(m.source->any(x | true)).oclIsKindOf(OntoUML!SubstanceSortal)) then ':>domain_of_quantification' else '' endif) + ',\n';
	    if ((m.isImmutablePart = true) or (m.isEssential = true) or (m.target->any(x | true).isReadOnly = true)) {
	    	world_facts <- world_facts + if ((tlrss.size() > 0) and (tlrst.size() > 0)) then ('	all x: ' + tlrss->any(x | true).name + ', w0, w1: (@' + m.name + '.x).' + tlrst->any(x | true).name + ' | (w0.@' + m.name + ').x = (w1.@' + m.name + ').x  -- essential or immutablePart or readOnly target.\n') else '' endif;
	    }
	    if ((m.isImmutableWhole = true) or (m.isInseparable = true) or (m.source->any(x | true).isReadOnly = true)) {
	    	world_facts <- world_facts + if ((tlrss.size() > 0) and (tlrst.size() > 0)) then ('	all x: ' + tlrst->any(x | true).name + ', w0, w1: (@' + m.name + '.' + tlrss->any(x | true).name + ').x | x.(w0.@' + m.name + ') = x.(w1.@' + m.name + ') -- inseparable or immutableWhole or readOnly source.\n') else '' endif;
	    }
		world_facts <- world_facts + (if (cardinality_fact_source <> '') then (cardinality_fact_source + '\n') else '' endif) + (if (cardinality_fact_target <> '') then (cardinality_fact_target + '\n') else '' endif);
		thisModule.signature_facts_world <- thisModule.signature_facts_world + world_facts;
		thisModule.text <- thisModule.final_text();
		thisModule.text.writeTo(thisModule.path);
		thisModule.debug('Meronymic ' + m.name);
	}
}

rule DatatypeRelationship2Relation {
    from
    	d: OntoUML!DatatypeRelationship (
    	    not d.source->exists(x | if x.oclIsKindOf(OntoUML!Property) then (thisModule.derive_endType(x).oclIsKindOf(OntoUML!StructuralDatatype)) else false endif)
    	)
    using {
    	    source_min_cardinality : Integer = d.source->any(x | true).lower;
    	    source_max_cardinality : Integer = d.source->any(x | true).upper;
    	    target_min_cardinality : Integer = d.target->any(x | true).lower;
    	    target_max_cardinality : Integer = d.target->any(x | true).upper;
			name : String = d.target->any(x | true).name;
    	    cardinality_source : String = '';
    	    cardinality_target : String = '';
			cardinality_fact_source : String = thisModule.cardinality_fact1(name,thisModule.name_side_source(d),d.target->any(x | true));
			cardinality_fact_target : String = thisModule.cardinality_fact2(name,thisModule.name_side_target(d),d.source->any(x | true));
			tlrss : OrderedSet (OntoUML!Classifier) = thisModule.top_level_rigid_sortals_connected_on_source(d);
			tlrst : OrderedSet (OntoUML!Classifier) = thisModule.top_level_rigid_sortals_connected_on_target(d);
			world_facts : String = '';
    	}
	do {
		if ((source_min_cardinality = 0) and (source_max_cardinality = 1)) {
		    cardinality_source <- 'lone';
		}
		else {
		    if ((source_min_cardinality = 1) and (source_max_cardinality = 1)) {
		        cardinality_source <- 'one';
		    }
		    else {
		        if ((source_min_cardinality = 1) and (source_max_cardinality = 0-1)) {
		            cardinality_source <- 'some';
		        }
		        else {
		            cardinality_source <- 'set';
		        }
		    }
		}
		if ((target_min_cardinality = 0) and (target_max_cardinality = 1)) {
		    cardinality_target <- 'lone';
		}
		else {
		    if ((target_min_cardinality = 1) and (target_max_cardinality = 1)) {
		        cardinality_target <- 'one';
		    }
		    else {
		        if ((target_min_cardinality = 1) and (target_max_cardinality = 0-1)) {
		            cardinality_target <- 'some';
		        }
		        else {
		            cardinality_target <- 'set';
		        }
		    }
		}
	    thisModule.relation_relations <- thisModule.relation_relations + '	' + name + ': set ' + thisModule.derive_endType(d.target->any(x | true)).name + (if (thisModule.derive_endType(d.target->any(x | true)).oclIsKindOf(OntoUML!SubstanceSortal)) then ':>domain_of_quantification' else '' endif) + ' ' + cardinality_target + ' -> ' + cardinality_source + ' ' + thisModule.derive_endType(d.source->any(x | true)).name + (if (thisModule.derive_endType(d.source->any(x | true)).oclIsKindOf(OntoUML!SubstanceSortal)) then ':>domain_of_quantification' else '' endif) + ',\n';
	    if (d.target->any(x | true).isReadOnly = true) {
	    	world_facts <- world_facts + if ((tlrss.size() > 0) and (tlrst.size() > 0)) then ('	all x: ' + tlrss->any(x | true).name + ', w0, w1: (@' + name + '.x).' + tlrst->any(x | true).name + ' | (w0.@' + name + ').x = (w1.@' + name + ').x  -- readOnly target.\n') else '' endif;
	    }
	    if (d.source->any(x | true).isReadOnly = true) {
	    	world_facts <- world_facts + if ((tlrss.size() > 0) and (tlrst.size() > 0)) then ('	all x: ' + tlrst->any(x | true).name + ', w0, w1: (@' + name + '.' + tlrss->any(x | true).name + ').x | x.(w0.@' + name + ') = x.(w1.@' + name + ') -- readOnly source.\n') else '' endif;
	    }
		world_facts <- world_facts + (if (cardinality_fact_source <> '') then (cardinality_fact_source + '\n') else '' endif) + (if (cardinality_fact_target <> '') then (cardinality_fact_target + '\n') else '' endif);
		thisModule.signature_facts_world <- thisModule.signature_facts_world + world_facts;
		thisModule.text <- thisModule.final_text();
		thisModule.text.writeTo(thisModule.path);
		thisModule.debug('DatatypeRelationship ' + name);
	}
}

rule Association2Relation {
    from
    	m: OntoUML!Association
    using {
    	    associationEnd1_min_cardinality : Integer = m.associationEnd->at(1).lower;
    	    associationEnd1_max_cardinality : Integer = m.associationEnd->at(1).upper;
    	    associationEnd2_min_cardinality : Integer = m.associationEnd->at(2).lower;
    	    associationEnd2_max_cardinality : Integer = m.associationEnd->at(2).upper;
    	    cardinality_associationEnd1 : String = '';
    	    cardinality_associationEnd2 : String = '';
			cardinality_fact_associationEnd1 : String = thisModule.cardinality_fact2(m.name,thisModule.name_side_associationEnd(m,1),m.associationEnd->at(2));
			cardinality_fact_associationEnd2 : String = thisModule.cardinality_fact1(m.name,thisModule.name_side_associationEnd(m,2),m.associationEnd->at(1));
			tlrsa1 : OrderedSet (OntoUML!Classifier) = thisModule.top_level_rigid_sortals_connected_on_associationEnd(m,1);
			tlrsa2 : OrderedSet (OntoUML!Classifier) = thisModule.top_level_rigid_sortals_connected_on_associationEnd(m,2);
			world_facts : String = '';
    	}
	do {
		if ((associationEnd1_min_cardinality = 0) and (associationEnd1_max_cardinality = 1)) {
		    cardinality_associationEnd1 <- 'lone';
		}
		else {
		    if ((associationEnd1_min_cardinality = 1) and (associationEnd1_max_cardinality = 1)) {
		        cardinality_associationEnd1 <- 'one';
		    }
		    else {
		        if ((associationEnd1_min_cardinality = 1) and (associationEnd1_max_cardinality = 0-1)) {
		            cardinality_associationEnd1 <- 'some';
		        }
		        else {
		            cardinality_associationEnd1 <- 'set';
		        }
		    }
		}
		if ((associationEnd2_min_cardinality = 0) and (associationEnd2_max_cardinality = 1)) {
		    cardinality_associationEnd2 <- 'lone';
		}
		else {
		    if ((associationEnd2_min_cardinality = 1) and (associationEnd2_max_cardinality = 1)) {
		        cardinality_associationEnd2 <- 'one';
		    }
		    else {
		        if ((associationEnd2_min_cardinality = 1) and (associationEnd2_max_cardinality = 0-1)) {
		            cardinality_associationEnd2 <- 'some';
		        }
		        else {
		            cardinality_associationEnd2 <- 'set';
		        }
		    }
		}
	    if (m.associationEnd->at(2).isReadOnly = true) {
	    	world_facts <- world_facts + if ((tlrsa1.size() > 0) and (tlrsa2.size() > 0)) then ('	all x: ' + tlrsa1->any(x | true).name + ', w0, w1: (@' + m.name + '.x).' + tlrsa2->any(x | true).name + ' | (w0.@' + m.name + ').x = (w1.@' + m.name + ').x  -- readOnly target.\n') else '' endif;
	    }
	    if (m.associationEnd->at(1).isReadOnly = true) {
	    	world_facts <- world_facts + if ((tlrsa1.size() > 0) and (tlrsa2.size() > 0)) then ('	all x: ' + tlrsa2->any(x | true).name + ', w0, w1: (@' + m.name + '.' + tlrsa1->any(x | true).name + ').x | x.(w0.@' + m.name + ') = x.(w1.@' + m.name + ') -- readOnly source.\n') else '' endif;
	    }		
	    thisModule.relation_relations <- thisModule.relation_relations + '	' + m.name + ': set ' + thisModule.derive_endType(m.associationEnd->at(1)).name + (if (thisModule.derive_endType(m.associationEnd->at(1)).oclIsKindOf(OntoUML!SubstanceSortal)) then ':>domain_of_quantification' else '' endif) + ' ' + cardinality_associationEnd2 + ' -> ' + cardinality_associationEnd1 + ' ' + thisModule.derive_endType(m.associationEnd->at(2)).name + (if (thisModule.derive_endType(m.associationEnd->at(2)).oclIsKindOf(OntoUML!SubstanceSortal)) then ':>domain_of_quantification' else '' endif) + ',\n';
		world_facts <- world_facts + (if (cardinality_fact_associationEnd1 <> '') then (cardinality_fact_associationEnd1 + '\n') else '' endif) + (if (cardinality_fact_associationEnd2 <> '') then (cardinality_fact_associationEnd2 + '\n') else '' endif);
		thisModule.signature_facts_world <- thisModule.signature_facts_world + world_facts;
		thisModule.text <- thisModule.final_text();
		thisModule.text.writeTo(thisModule.path);
		thisModule.debug('Association ' + m.name);
	}
}

rule GeneralizationSet2Fact {
    from
    	g : OntoUML!GeneralizationSet (
    		(g.isDisjoint or g.isCovering) -- Otherwise, this fact would have no body.
    		and not g.generalization->collect(x | thisModule.derive_specific(x))->forAll(x | x.oclIsKindOf(OntoUML!SubKind))
    	)
    using {
    	general : OntoUML!Element = g.generalization->collect(x | thisModule.derive_general(x))->any(x | true);
    	specifics : OrderedSet(OntoUML!Element) = g.generalization->collect(x | thisModule.derive_specific(x));
    	facts : String = '';
    }
    do {
        if (specifics->forAll(x | x.oclIsKindOf(OntoUML!Relationship))) { -- If the generalizations are between associations.
            if ((g.isDisjoint = true) and (specifics->size() >= 2)) {
                facts <- '	disj[' + thisModule.names_list(specifics) + ']\n';
                if (g.isCovering = true)
                	facts <- facts + '	' + general.name + ' = ' + thisModule.names_union_set(specifics) + '\n';
            }
            else {
                if (g.isCovering = true)
					facts <- facts + '	' + general.name + ' = ' + thisModule.names_union_set(specifics) + '\n';
            }
        }
    	else { -- If the generalizations are between classes.
            if ((g.isDisjoint = true) and (specifics->size() >= 2)) {
                facts <- '	disj[' + thisModule.names_list(specifics) + ']\n';
                if (g.isCovering = true)
                    if (general.oclIsKindOf(OntoUML!SubstanceSortal) or general.oclIsKindOf(OntoUML!Relator))
                		facts <- facts + '	' + general.name + ':> domain_of_quantification = ' + thisModule.names_union_set(specifics) + '\n';
                    else
                        facts <- facts + '	' + general.name + ' = ' + thisModule.names_union_set(specifics) + '\n';
            }
            else {
                if (g.isCovering = true)
                    if (general.oclIsKindOf(OntoUML!SubstanceSortal) or general.oclIsKindOf(OntoUML!Relator))
                		facts <- '	' + general.name + ':> domain_of_quantification = ' + thisModule.names_union_set(specifics) + '\n';
                    else
                        facts <- '	' + general.name + ' = ' + thisModule.names_union_set(specifics) + '\n';
            }    	    
    	} 	  	
		thisModule.signature_facts_world <- thisModule.signature_facts_world + facts;
		thisModule.text <- thisModule.final_text();
		thisModule.text.writeTo(thisModule.path);
		thisModule.debug('GeneralizationSet ' + g.name);
    }    	
}